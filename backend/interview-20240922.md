## Java

### 객체지향이 뭔가요?

```text
먼저 사물의 속성과 기능을 모두 포함된 객체로 만듭니다. 그리고 객체지향에서는 이렇게 만들어진 객체들 간의 결합과 조합을 통해 하나의 프로그램을 만드는 패러다임을 말합니다.

그리고 이런 객체지향을 사용하는 이유는 캡슐화, 상속화, 추상화, 다형성을 특징으로 인해 코드의 재사용을 줄이고, 변경을 쉽게 할 수 있습니다. 
```

### 이렇게 코드의 재사용성과 변경을 쉽게 하는게 왜 중요한가요?

```text
재사용성을 줄일 수 있다는 것은 코드 양을 줄여 복잡도를 낮추고 이로써 개발자가 실수할 일이 줄어듭니다.
또한, 변경이 쉬우면 개발이 확장되고, 집중하고 있는 부분만 수정하면 되기 때문에 이 또한, 복잡도를 낮추고 개발자가 실수할 일이 줄어들며
결과적으로 유지보수를 어렵게하지 않으며, 쓸데없는 시간과 비용을 낭비하지 않습니다.
```


### 객체지향의 4가지 특징을 말해주세요
(캡상추다~)
```text
- 캡슐화는 객체 내부의 속성이나 기능을 외부에서 직접 접근할 수 없게 합니다.  
- 상속은 기존의 클래스를 재활용하여 새로운 클래스를 작성하여 기능을 확장할 수 있게 합니다.
- 추상화는 객체들의 공통적인 속성과 기능을 추출하여 정의하는 것을 말합니다. 그리고 이 추상화를 구현할 수 있는 방법은 추상클래스와 인터페이스가 있습니다.
- 다형성은 한 타입의 참조변수를 통해 해당 타입의 다양한 구현 객체를 참조할 수 있습니다. 
```

### 이러한 4가지 특성을 효과적으로 활용한 설계기법을 말해주세요

```text
SOLID는 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙이며, 디자인 패턴은 더 특정한 상황에 적용될 수 있는 설계 기법입니다.

SOLID를 설명해드리면, 
- 단일책임원칙인 SRP 는 한 클래스에 하나의 책임만 가져야 한다는 원칙입니다.
- 개방폐쇄원칙인 OCP 는 한 클래스의 변경은 최소화하면서, 확장에는 열려있게 해야합니다.
- 리스코프치환원칙인 LSP 는 서브타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 합니다. 그리고 하위 클래스의 인스턴스는 상위 클래스의 인스턴스 역할을 수행하는데 문제가 없어야 합니다.
- 인터페이스 분리 원칙 ISP 는 SRP와 비슷하며, 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫습니다.
- 의존관계 역전 원칙인 DIP 는 추상화에 의존해야 하며, 구체화에 의존하면 안 됩니다.
```


## 네트워크 

### 브라우저에 URL을 쳤을 때 무슨 일이 일어나나요?
```text
- 예를들어 브라우저에 https://www.naver.com 인 URL을 입력하고 Enter 키를 누릅니다.
- 브라우저는 해당 URL을 파싱합니다. (https는 통신 프로토콜로 TLS를 사용하여 서버에 연결하도록 지시합니다. / 도메인 / 경로 / 리소스)
- 브라우저는 도메인의 IP 주소를 알아내기 위해 먼저, 브라우저 캐시를 확인하고 없으면 hosts 파일과 OS 캐시를 확인합니다.
- 여기에도 없다면 DNS 서버에게 IP 주소를 질의합니다.
- 먼저 로컬 DNS 서버는 캐시를 확인하고 없으면 Root Name Server에게 com이 있는 TLD Name Server 주소를 받습니다.
- 그리고 TLD Name Server에서 sub domain Name Server 주소를 받고 sub domain Name Server에서 IP 주소를 받게 되고 최종적으로 브라우저에게 도착하게 됩니다.
- IP 주소를 받은 웹 브라우저가 서버와의 TCP 연결을 시작하기 위해 요청 패킷을 TCP/IP 라는 전송제어 프로토콜을 사용하여 라우터 장비와 ISP를 통해 이동하는데 라우팅 테이블을 사용하여 최적의 경로를 찾아 목적지 IP 주소를 가진 웹 서버에 도달합니다.
- 보통 웹서버 대신 캐싱된 정적 콘텐츠을 가진 CDN에 먼저 도달합니다. 
- 브라우저는 서버와의 TCP 연결을 시작합니다. 이때 TCP는 3-way handshake 방식으로 연결합니다.
- HTTPS 프로토콜의 경우 추가적으로 TLS Handshake를 수행합니다.
- 웹 브라우저가 서버에 연결되면, 웹 브라우저가 페이지의 콘텐츠를 응답받기 위해 서버에 HTTP 요청을 전송하는 것으로 시작합니다.
- 서버는 받은 패킷안에 HTTP 메세지를 확인하고 올바른 요청일 경우 요청에 대한 응답을 생성하고 클라이언트에게 보냅니다.
- 웹 브라우저가 서버로 부터 응답을 받으면 응답 헤더를 검사하여 리소스를 렌더링하는 방법에 대한 정보를 확인합니다. 만약 Content-Type이 HTML인 경우,
- 브라우저는 HTML을 파싱하고 렌더링 합니다.
- 만약, 동적인 컨텐츠를 요청할 때 웹 서버는 클라이언트의 요청을 웹 애플리케이션 서버에 전달합니다.
- WAS는 관련된 Servlet을 메모리에 올리고, 해당 Servlet에 대한 Thread를 생성합니다. 그리고 HttpServletRequest와 HttpServletResponse 객체를 생성하여 필터를 거쳐 디스패처서블릿에 전달합니다.
- 그후 디스패처서블릿의 일련의 과정을 거친 후 Response 객체를 Servlet Container에 의해 HTTP 응답으로 변환되어 클라이언트에게 전송됩니다
- Web Server는 결과를 클라이언트에게 전달합니다.
```

### CDN이 뭔가요?

```text
CDN은 전 세계 여러 위치에 분산된 서버 네트워크로, 웹사이트의 콘텐츠를 캐싱(임시 저장)하고 제공합니다.

주요 이점으로는 
지연 시간 감소: 사용자와 가까운 서버에서 콘텐츠 제공
트래픽 분산: 여러 서버에 부하를 분산시켜 원본 서버의 부담 감소
보안 강화: DDoS 공격 등으로부터 보호 기능 제공
신뢰성 향상: 서버 장애 시 다른 서버로 자동 전환

사용 예:
대형 웹사이트: 아마존, 넷플릭스 등
뉴스 사이트: 갑작스러운 트래픽 증가 대응
게임 회사: 대용량 파일의 빠른 다운로드 제공
```

### TLS HandShake 설명해주세요

```text
1. (사전 단계) CA 인증기관에서 서버의 공개키와 정보를 인증기관의 개인키로 서명하여 인증서를 제작하고 서버에 전달합니다.

2. 클라이언트가 서버에 연결을 요청합니다 (ClientHello).

3. 서버는 자신의 인증서를 클라이언트에게 전송합니다 (ServerHello, Certificate).

4. 클라이언트는 자신이 신뢰하는 CA의 공개키로 인증서를 검증합니다.

5. 검증이 성공하면 클라이언트는 서버의 공개키를 획득합니다.

6. 클라이언트는 임시 대칭키(세션 키)를 생성하고, 이를 서버의 공개키로 암호화하여 서버에 전송합니다.

7. 서버는 자신의 개인키로 암호화된 세션 키를 복호화하여 획득합니다.

8. 이제 클라이언트와 서버는 동일한 세션 키를 공유하게 되어, 이후의 통신에서 이 대칭키를 사용하여 데이터를 암호화하고 복호화합니다.
```


### 프로토콜이란

```text
프로토콜은 네트워크 상에서 기기들이 '대화'하는 방법을 정의합니다.
```


## 데이터베이스 

### 뮤택스와 세마포어 차이?

```text
뮤텍스와 세마포어는 둘 다 멀티스레딩 환경에서 공유 자원에 대한 접근을 제어하는 동기화 메커니즘입니다. 하지만 몇 가지 중요한 차이가 있습니다.

뮤텍스는, 한 번에 하나의 스레드만 자원에 접근할 수 있게 합니다.
세마포어는 여러 스레드가 동시에 접근할 수 있는 자원의 수를 제어합니다. 

뮤텍스는 주로 상호 배제, 즉 임계 영역 보호에 사용됩니다.
세마포어는 상호 배제뿐만 아니라 자원 관리 등 더 넓은 범위에 사용됩니다.

실제 적용 예를 들면, 뮤텍스는 파일 쓰기 작업을 보호할 때 사용할 수 있습니다. 한 번에 하나의 스레드만 파일에 쓸 수 있도록 보장하죠. 
반면 세마포어는 동시에 사용 가능한 데이터베이스 연결 수를 제한할 때 사용할 수 있습니다. 
예를 들어, 최대 10개의 연결만 허용하는 식으로요.
```